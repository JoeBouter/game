<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate 3D Driving Simulator</title>
    <style>
        /* ========== GLOBAL STYLES ========== */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: white;
        }

        canvas {
            display: block;
        }

        /* ========== HUD STYLES ========== */
        #hud-container {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
            pointer-events: none;
        }

        .hud-panel {
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            min-width: 180px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .hud-title {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .hud-value {
            font-size: 24px;
            font-weight: bold;
        }

        #speed-value { color: #4CAF50; }
        #score-value { color: #FFC107; }
        #time-value { color: #03A9F4; }
        #gear-value { color: #F44336; }

        /* ========== MENU STYLES ========== */
        #menu-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 200;
            transition: opacity 0.3s ease;
        }

        #menu-title {
            font-size: 72px;
            margin-bottom: 40px;
            color: #FFC107;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
        }

        .menu-button {
            background: linear-gradient(135deg, #FFC107, #FF9800);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            margin: 10px;
            cursor: pointer;
            min-width: 250px;
            text-align: center;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 193, 7, 0.4);
        }

        /* ========== GAME OVER STYLES ========== */
        #game-over-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 300;
        }

        #game-over-title {
            font-size: 72px;
            color: #F44336;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
            font-family: 'Impact', sans-serif;
        }

        #game-over-stats {
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        .game-over-stat {
            margin: 15px 0;
            font-size: 18px;
        }

        .stat-value {
            font-weight: bold;
            color: #FFC107;
        }

        /* ========== MESSAGE POPUPS ========== */
        #message-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 10px;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #message-text {
            font-size: 18px;
            color: white;
            text-align: center;
        }

        /* ========== MINIMAP STYLES ========== */
        #minimap-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            z-index: 100;
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        /* ========== LOADING SCREEN ========== */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        #loading-bar-container {
            width: 300px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }

        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FFC107, #FF9800);
            transition: width 0.3s ease;
        }

        #loading-text {
            margin-top: 15px;
            font-size: 16px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <h1>LOADING GAME...</h1>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-text">Initializing 3D engine...</div>
    </div>

    <!-- HUD Elements -->
    <div id="hud-container">
        <div class="hud-panel">
            <div class="hud-title">SPEED</div>
            <div id="speed-value" class="hud-value">0 MPH</div>
        </div>
        <div class="hud-panel">
            <div class="hud-title">SCORE</div>
            <div id="score-value" class="hud-value">0</div>
        </div>
        <div class="hud-panel">
            <div class="hud-title">TIME</div>
            <div id="time-value" class="hud-value">0:00</div>
        </div>
        <div class="hud-panel">
            <div class="hud-title">GEAR</div>
            <div id="gear-value" class="hud-value">N</div>
        </div>
    </div>

    <!-- Minimap -->
    <div id="minimap-container">
        <canvas id="minimap"></canvas>
    </div>

    <!-- Message Popup -->
    <div id="message-container">
        <div id="message-text"></div>
    </div>

    <!-- Main Menu -->
    <div id="menu-container">
        <h1 id="menu-title">DRIVING SIMULATOR</h1>
        <button class="menu-button" id="start-button">START GAME</button>
        <button class="menu-button" id="controls-button">CONTROLS</button>
        <button class="menu-button" id="about-button">ABOUT</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-container">
        <h1 id="game-over-title">GAME OVER</h1>
        <div id="game-over-stats">
            <div class="game-over-stat">FINAL SCORE: <span id="final-score" class="stat-value">0</span></div>
            <div class="game-over-stat">DISTANCE: <span id="final-distance" class="stat-value">0</span> MILES</div>
            <div class="game-over-stat">TIME: <span id="final-time" class="stat-value">0:00</span></div>
            <div class="game-over-stat">TOP SPEED: <span id="final-speed" class="stat-value">0</span> MPH</div>
            <div class="game-over-stat">CARS PASSED: <span id="final-passed" class="stat-value">0</span></div>
        </div>
        <button class="menu-button" id="restart-button">PLAY AGAIN</button>
    </div>

    <!-- Three.js and Game Code -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script>
        // =============================================
        // ========== GAME INITIALIZATION ==========
        // =============================================

        // Main Three.js variables
        let scene, camera, renderer, controls, minimapCamera, minimapRenderer;
        
        // Game state variables
        let gameActive = false;
        let gameTime = 0;
        let gameDistance = 0;
        let gameScore = 0;
        let carsPassed = 0;
        let topSpeed = 0;
        let loadingProgress = 0;
        let assetsLoaded = false;
        
        // Player variables
        let playerCar, playerSpeed = 0, playerAcceleration = 0;
        let playerPosition = { x: 0, y: 0, z: 0 };
        let currentGear = 'N';
        let gearShiftTimer = 0;
        
        // Environment variables
        let road, roadSegments = [];
        let dayNightCycle = 0.25; // Start at morning
        let weather = 0; // 0=clear, 1=rainy
        let sunLight, ambientLight, fog;
        
        // Traffic variables
        let trafficCars = [];
        let trafficDensity = 0.5;
        let lastCarSpawnTime = 0;
        
        // Camera variables
        let currentCameraMode = 'chase';
        const cameraModes = ['chase', 'hood', 'orbit', 'top'];
        let cameraTransition = 0;
        
        // Input variables
        const keys = {
            w: false, a: false, s: false, d: false,
            arrowup: false, arrowleft: false, arrowright: false, arrowdown: false,
            shift: false, space: false, c: false
        };
        
        // Game settings
        const settings = {
            mouseSensitivity: 0.002,
            maxSpeed: 180, // mph
            acceleration: 0.5,
            braking: 1.2,
            steering: 0.05,
            roadWidth: 20,
            segmentLength: 200,
            segmentCount: 3,
            gearShiftSpeed: 30 // mph
        };

        // =============================================
        // ========== MAIN GAME FUNCTIONS ==========
        // =============================================

        function init() {
            // Setup loading progress
            updateLoadingProgress(0, "Initializing 3D engine...");
            
            // Create Three.js scene
            createScene();
            updateLoadingProgress(10, "Creating environment...");
            
            // Create player and environment
            createPlayer();
            updateLoadingProgress(30, "Building road system...");
            
            createEnvironment();
            updateLoadingProgress(50, "Setting up lighting...");
            
            // Setup UI and event listeners
            createEventListeners();
            updateLoadingProgress(70, "Initializing controls...");
            
            setupUI();
            updateLoadingProgress(90, "Finalizing setup...");
            
            // Complete loading
            setTimeout(() => {
                assetsLoaded = true;
                document.getElementById('loading-screen').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = 'none';
                    showMenu();
                }, 300);
                updateLoadingProgress(100, "Ready to play!");
            }, 1500);
        }

        function createScene() {
            // Create Three.js scene with fog
            scene = new THREE.Scene();
            fog = new THREE.FogExp2(0x87CEEB, 0.0005);
            scene.fog = fog;
            
            // Setup renderer with antialiasing and shadows
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            document.body.appendChild(renderer.domElement);
            
            // Create main camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 5, 10);
            
            // Create minimap camera and renderer
            minimapCamera = new THREE.OrthographicCamera(-50, 50, 50, -50, 1, 1000);
            minimapCamera.position.set(0, 100, 0);
            minimapCamera.lookAt(0, 0, 0);
            
            minimapRenderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('minimap'),
                antialias: true
            });
            minimapRenderer.setSize(150, 150);
            minimapRenderer.setClearColor(0x333333);
            
            // Orbit controls for debugging (disabled in game)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false;
            
            // Add window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function createPlayer() {
            // Car body
            const carBodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const carBodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00AA00,
                metalness: 0.7,
                roughness: 0.3
            });
            playerCar = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            playerCar.castShadow = true;
            playerCar.receiveShadow = true;
            playerCar.position.set(0, 0.5, 0);
            scene.add(playerCar);
            
            // Car details (windows, etc)
            const carWindowGeometry = new THREE.BoxGeometry(1.8, 0.5, 3.8);
            const carWindowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const carWindows = new THREE.Mesh(carWindowGeometry, carWindowMaterial);
            carWindows.position.y = 0.3;
            playerCar.add(carWindows);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 32);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const wheelPositions = [
                { x: -1, y: -0.5, z: 1.5 },
                { x: 1, y: -0.5, z: 1.5 },
                { x: -1, y: -0.5, z: -1.5 },
                { x: 1, y: -0.5, z: -1.5 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                playerCar.add(wheel);
            });
            
            // Headlights
            const headlight1 = new THREE.SpotLight(0xFFFFFF, 2, 100, Math.PI/6, 0.5);
            headlight1.position.set(-0.5, 0.3, -2);
            headlight1.target.position.set(-0.5, 0, -10);
            headlight1.castShadow = true;
            headlight1.shadow.bias = -0.001;
            playerCar.add(headlight1);
            playerCar.add(headlight1.target);
            
            const headlight2 = new THREE.SpotLight(0xFFFFFF, 2, 100, Math.PI/6, 0.5);
            headlight2.position.set(0.5, 0.3, -2);
            headlight2.target.position.set(0.5, 0, -10);
            headlight2.castShadow = true;
            headlight2.shadow.bias = -0.001;
            playerCar.add(headlight2);
            playerCar.add(headlight2.target);
            
            // Brake lights
            const brakeLightGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.1);
            const brakeLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0
            });
            
            const brakeLight1 = new THREE.Mesh(brakeLightGeometry, brakeLightMaterial);
            brakeLight1.position.set(-0.6, 0.2, -2);
            playerCar.add(brakeLight1);
            
            const brakeLight2 = new THREE.Mesh(brakeLightGeometry, brakeLightMaterial);
            brakeLight2.position.set(0.6, 0.2, -2);
            playerCar.add(brakeLight2);
        }

        function createEnvironment() {
            // Road
            createRoad();
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3A5F0B,
                roughness: 1.0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Lighting
            createLighting();
            
            // Add some scenery
            createScenery();
        }

        function createRoad() {
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8
            });
            
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.2
            });
            
            for (let i = 0; i < settings.segmentCount; i++) {
                const roadGeometry = new THREE.PlaneGeometry(settings.roadWidth, settings.segmentLength);
                const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
                roadSegment.rotation.x = -Math.PI / 2;
                roadSegment.position.z = -settings.segmentLength * i;
                roadSegment.receiveShadow = true;
                scene.add(roadSegment);
                roadSegments.push(roadSegment);
                
                // Road markings
                for (let z = -settings.segmentLength/2; z < settings.segmentLength/2; z += 10) {
                    const lineGeometry = new THREE.PlaneGeometry(1, 0.2);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(0, 0.01, z - settings.segmentLength * i);
                    line.receiveShadow = true;
                    scene.add(line);
                }
            }
        }

        function createLighting() {
            // Ambient light
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            ambientLight.name = 'ambientLight';
            scene.add(ambientLight);
            
            // Directional light (sun)
            sunLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
            sunLight.name = 'sunLight';
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);
            
            // Update lighting based on initial day cycle
            updateLighting();
        }

        function createScenery() {
            // Add some trees and buildings
            const treeGeometry = new THREE.ConeGeometry(1, 3, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
            
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            
            for (let i = 0; i < 100; i++) {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.5;
                trunk.castShadow = true;
                tree.add(trunk);
                
                const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
                leaves.position.y = 2.5;
                leaves.castShadow = true;
                tree.add(leaves);
                
                // Position trees randomly along the sides of the road
                const side = Math.random() > 0.5 ? 1 : -1;
                tree.position.x = (settings.roadWidth/2 + 5 + Math.random() * 20) * side;
                tree.position.z = -Math.random() * settings.segmentLength * settings.segmentCount;
                
                scene.add(tree);
            }
        }

        function createEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) {
                    keys[key] = true;
                }
                
                // Camera switch
                if (key === 'c') {
                    switchCamera();
                }
                
                // Pause game
                if (key === 'escape' && gameActive) {
                    pauseGame();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) {
                    keys[key] = false;
                }
            });
            
            // UI buttons
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            document.getElementById('controls-button').addEventListener('click', showControls);
            document.getElementById('about-button').addEventListener('click', showAbout);
        }

        function setupUI() {
            // Initialize all UI elements
            updateHUD();
        }

        // =============================================
        // ========== GAME LOOP FUNCTIONS ==========
        // =============================================

        function gameLoop(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = Math.min(0.05, (timestamp - lastTimestamp) / 1000);
            lastTimestamp = timestamp;
            
            if (gameActive) {
                updatePlayer(deltaTime);
                updateTraffic(deltaTime);
                updateEnvironment(deltaTime);
                updateCamera(deltaTime);
                updateHUD();
                updateMinimap();
                
                // Check for collisions
                checkCollisions();
                
                // Spawn new traffic
                spawnTraffic(deltaTime);
                
                // Update game time
                gameTime += deltaTime;
                
                // Update game distance (for score)
                gameDistance += playerSpeed * deltaTime / 3600; // in miles
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        function updatePlayer(deltaTime) {
            // Acceleration
            if (keys.w || keys.arrowup) {
                playerAcceleration = settings.acceleration;
            } 
            // Braking
            else if (keys.s || keys.arrowdown) {
                playerAcceleration = -settings.braking;
            }
            // Coasting
            else {
                playerAcceleration = -0.2; // natural deceleration
            }
            
            // Update speed
            playerSpeed += playerAcceleration * deltaTime * 20;
            playerSpeed = Math.max(0, Math.min(playerSpeed, settings.maxSpeed));
            
            // Update gear
            updateGear(deltaTime);
            
            // Steering
            if (keys.a || keys.arrowleft) {
                playerPosition.x -= settings.steering * (0.5 + playerSpeed/settings.maxSpeed) * deltaTime * 50;
            }
            if (keys.d || keys.arrowright) {
                playerPosition.x += settings.steering * (0.5 + playerSpeed/settings.maxSpeed) * deltaTime * 50;
            }
            
            // Keep player on road
            playerPosition.x = THREE.MathUtils.clamp(
                playerPosition.x,
                -settings.roadWidth/2 + 2,
                settings.roadWidth/2 - 2
            );
            
            // Update player car position
            playerCar.position.x = playerPosition.x;
            
            // Update top speed
            if (playerSpeed > topSpeed) {
                topSpeed = playerSpeed;
            }
            
            // Animate wheels
            const wheels = playerCar.children.filter(child => child.geometry instanceof THREE.CylinderGeometry);
            wheels.forEach(wheel => {
                wheel.rotation.x -= playerSpeed * deltaTime * 0.02;
            });
            
            // Update brake lights
            const brakeLights = playerCar.children.filter(child => 
                child.material && child.material.emissiveIntensity !== undefined
            );
            brakeLights.forEach(light => {
                light.material.emissiveIntensity = playerAcceleration < -0.5 ? 1 : 0;
            });
        }

        function updateGear(deltaTime) {
            if (gearShiftTimer > 0) {
                gearShiftTimer -= deltaTime;
                return;
            }
            
            const mph = playerSpeed * 2.23694;
            
            if (mph < 10) {
                if (currentGear !== 'N') {
                    currentGear = 'N';
                    gearShiftTimer = 0.5;
                }
            } else if (mph < settings.gearShiftSpeed) {
                if (currentGear !== '1') {
                    currentGear = '1';
                    gearShiftTimer = 0.5;
                }
            } else if (mph < settings.gearShiftSpeed * 2) {
                if (currentGear !== '2') {
                    currentGear = '2';
                    gearShiftTimer = 0.5;
                }
            } else if (mph < settings.gearShiftSpeed * 3) {
                if (currentGear !== '3') {
                    currentGear = '3';
                    gearShiftTimer = 0.5;
                }
            } else if (mph < settings.gearShiftSpeed * 4) {
                if (currentGear !== '4') {
                    currentGear = '4';
                    gearShiftTimer = 0.5;
                }
            } else {
                if (currentGear !== '5') {
                    currentGear = '5';
                    gearShiftTimer = 0.5;
                }
            }
            
            document.getElementById('gear-value').textContent = currentGear;
        }

        function updateTraffic(deltaTime) {
            // Move all traffic cars
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const car = trafficCars[i];
                
                // Move car forward
                car.position.z += car.speed * deltaTime;
                
                // Simple AI for lane changes
                if (Math.random() < 0.01) {
                    car.lane = Math.random() > 0.5 ? -3 : 3;
                }
                
                // Move toward target lane
                car.position.x += (car.lane - car.position.x) * 0.05;
                
                // Remove cars that are behind player
                if (car.position.z > playerCar.position.z + 20) {
                    scene.remove(car);
                    trafficCars.splice(i, 1);
                    carsPassed++;
                }
            }
        }

        function updateEnvironment(deltaTime) {
            // Move road segments (create illusion of movement)
            roadSegments.forEach(segment => {
                segment.position.z += playerSpeed * deltaTime;
                
                // Loop segments when they go too far back
                if (segment.position.z > settings.segmentLength/2) {
                    segment.position.z -= settings.segmentLength * settings.segmentCount;
                }
            });
            
            // Update day/night cycle
            dayNightCycle = (dayNightCycle + deltaTime / 120) % 1; // 2 minute cycle
            updateLighting();
        }

        function updateLighting() {
            // Update sun position based on day/night cycle
            const sunAngle = dayNightCycle * Math.PI * 2;
            
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.max(0, Math.sin(sunAngle)) * 100;
            sunLight.intensity = sunLight.position.y > 0 ? 1.0 : 0.1;
            
            // Update ambient light based on time of day
            ambientLight.intensity = 0.3 + 0.2 * Math.sin(sunAngle);
            
            // Update fog
            const fogIntensity = 0.5 + 0.3 * Math.sin(sunAngle);
            fog.color.setHSL(0.6, 0.5, fogIntensity);
            fog.density = 0.0003 + (1 - fogIntensity) * 0.0002;
            
            // Update renderer exposure
            renderer.toneMappingExposure = 1.0 + Math.sin(sunAngle) * 0.5;
        }

        function updateCamera(deltaTime) {
            // Camera transitions
            if (cameraTransition > 0) {
                cameraTransition -= deltaTime;
            }
            
            // Different camera modes
            switch (currentCameraMode) {
                case 'chase':
                    // Third-person chase camera
                    const chaseDistance = 5 + playerSpeed / 50;
                    const chaseHeight = 2 + playerSpeed / 100;
                    
                    const targetPosition = new THREE.Vector3(
                        playerCar.position.x,
                        playerCar.position.y + chaseHeight,
                        playerCar.position.z - chaseDistance
                    );
                    
                    camera.position.lerp(targetPosition, 0.1);
                    camera.lookAt(playerCar.position);
                    break;
                    
                case 'hood':
                    // First-person hood camera
                    const hoodPosition = new THREE.Vector3(
                        playerCar.position.x,
                        playerCar.position.y + 0.5,
                        playerCar.position.z + 1.5
                    );
                    
                    camera.position.lerp(hoodPosition, 0.2);
                    camera.quaternion.slerp(playerCar.quaternion, 0.1);
                    break;
                    
                case 'orbit':
                    // Orbit camera around car
                    const time = gameTime * 0.5;
                    const orbitRadius = 8;
                    const orbitPosition = new THREE.Vector3(
                        playerCar.position.x + Math.cos(time) * orbitRadius,
                        playerCar.position.y + 5,
                        playerCar.position.z + Math.sin(time) * orbitRadius
                    );
                    
                    camera.position.lerp(orbitPosition, 0.05);
                    camera.lookAt(playerCar.position);
                    break;
                    
                case 'top':
                    // Top-down camera
                    const topPosition = new THREE.Vector3(
                        playerCar.position.x,
                        playerCar.position.y + 15,
                        playerCar.position.z - 5
                    );
                    
                    camera.position.lerp(topPosition, 0.1);
                    camera.lookAt(playerCar.position);
                    break;
            }
        }

        function updateHUD() {
            // Update speed (convert to mph)
            document.getElementById('speed-value').textContent = Math.round(playerSpeed * 2.23694);
            
            // Update score (based on distance and speed)
            gameScore = Math.floor(gameDistance * 100 + playerSpeed * gameTime / 10);
            document.getElementById('score-value').textContent = gameScore;
            
            // Update time (format as MM:SS)
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            document.getElementById('time-value').textContent = 
                `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        function updateMinimap() {
            // Update minimap camera position
            minimapCamera.position.set(
                playerCar.position.x,
                100,
                playerCar.position.z
            );
            minimapCamera.lookAt(playerCar.position);
            
            // Render minimap
            minimapRenderer.render(scene, minimapCamera);
        }

        function spawnTraffic(deltaTime) {
            // Spawn new traffic based on density and player speed
            const spawnChance = trafficDensity * (0.01 + playerSpeed / settings.maxSpeed * 0.05);
            
            if (Math.random() < spawnChance * deltaTime * 60) {
                createTrafficCar();
            }
        }

        function createTrafficCar() {
            const colors = [
                0xFF0000, 0x0000FF, 0xFFFF00, 0xFFA500, 
                0x800080, 0xFFFFFF, 0x00FF00, 0xFF00FF
            ];
            
            const carGeometry = new THREE.BoxGeometry(2, 1, 4);
            const carMaterial = new THREE.MeshStandardMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)],
                metalness: 0.5,
                roughness: 0.5
            });
            
            const car = new THREE.Mesh(carGeometry, carMaterial);
            car.castShadow = true;
            car.receiveShadow = true;
            
            // Position car in one of the lanes
            const lane = Math.random() > 0.5 ? -3 : 3;
            car.position.set(
                lane,
                0.5,
                playerCar.position.z - 50 - Math.random() * 50
            );
            
            // Set car properties
            car.speed = 15 + Math.random() * 10; // mph
            car.lane = lane;
            
            scene.add(car);
            trafficCars.push(car);
        }

        function checkCollisions() {
            for (const car of trafficCars) {
                const distance = Math.sqrt(
                    Math.pow(car.position.x - playerCar.position.x, 2) +
                    Math.pow(car.position.z - playerCar.position.z, 2)
                );
                
                if (distance < 2.5) {
                    // Collision detected
                    handleCollision();
                    break;
                }
            }
        }

        function handleCollision() {
            // Reduce speed on collision
            playerSpeed *= 0.5;
            
            // Check if game over (if speed was high enough)
            if (playerSpeed > 30) {
                endGame();
            } else {
                showMessage("Collision! Be careful!", 2000);
            }
        }

        // =============================================
        // ========== GAME STATE FUNCTIONS ==========
        // =============================================

        function startGame() {
            // Reset game state
            resetGame();
            
            // Hide menu
            document.getElementById('menu-container').style.display = 'none';
            
            // Start game loop
            gameActive = true;
            lastTimestamp = 0;
            requestAnimationFrame(gameLoop);
        }

        function pauseGame() {
            gameActive = !gameActive;
            
            if (gameActive) {
                document.getElementById('menu-container').style.display = 'none';
                lastTimestamp = performance.now();
                requestAnimationFrame(gameLoop);
            } else {
                document.getElementById('menu-container').style.display = 'flex';
                document.getElementById('menu-title').textContent = 'PAUSED';
            }
        }

        function endGame() {
            gameActive = false;
            
            // Update final stats
            document.getElementById('final-score').textContent = gameScore;
            document.getElementById('final-distance').textContent = gameDistance.toFixed(2);
            document.getElementById('final-time').textContent = 
                `${Math.floor(gameTime / 60)}:${Math.floor(gameTime % 60).toString().padStart(2, '0')}`;
            document.getElementById('final-speed').textContent = Math.round(topSpeed * 2.23694);
            document.getElementById('final-passed').textContent = carsPassed;
            
            // Show game over screen
            document.getElementById('game-over-container').style.display = 'flex';
        }

        function restartGame() {
            // Hide game over screen
            document.getElementById('game-over-container').style.display = 'none';
            
            // Start new game
            startGame();
        }

        function resetGame() {
            // Reset player
            playerCar.position.set(0, 0.5, 0);
            playerSpeed = 0;
            playerAcceleration = 0;
            playerPosition = { x: 0, y: 0, z: 0 };
            currentGear = 'N';
            
            // Reset game stats
            gameTime = 0;
            gameDistance = 0;
            gameScore = 0;
            carsPassed = 0;
            topSpeed = 0;
            
            // Clear traffic
            trafficCars.forEach(car => scene.remove(car));
            trafficCars = [];
            
            // Reset camera
            currentCameraMode = 'chase';
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Reset day/night cycle
            dayNightCycle = 0.25;
            updateLighting();
        }

        function switchCamera() {
            const currentIndex = cameraModes.indexOf(currentCameraMode);
            currentCameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
            cameraTransition = 0.5;
            
            showMessage(`Camera: ${currentCameraMode.toUpperCase()}`, 1000);
        }

        // =============================================
        // ========== UI FUNCTIONS ==========
        // =============================================

        function showMenu() {
            document.getElementById('menu-container').style.display = 'flex';
            document.getElementById('menu-title').textContent = 'DRIVING SIMULATOR';
        }

        function showControls() {
            alert(
                "GAME CONTROLS:\n\n" +
                "W / Up Arrow - Accelerate\n" +
                "S / Down Arrow - Brake\n" +
                "A / Left Arrow - Steer Left\n" +
                "D / Right Arrow - Steer Right\n" +
                "C - Switch Camera View\n" +
                "ESC - Pause Game\n\n" +
                "OBJECTIVE:\n" +
                "Drive as far as you can without crashing!\n" +
                "Higher speeds give more points but are harder to control."
            );
        }

        function showAbout() {
            alert(
                "ULTIMATE DRIVER\n\n" +
                "A 3D driving game built with Three.js\n\n" +
                "Features:\n" +
                "- Realistic physics and controls\n" +
                "- Dynamic day/night cycle\n" +
                "- Intelligent traffic AI\n" +
                "- Multiple camera angles\n" +
                "- Beautiful 3D graphics\n\n" +
                "Created for educational purposes"
            );
        }

        function showMessage(text, duration = 2000) {
            const message = document.getElementById('message-container');
            const messageText = document.getElementById('message-text');
            
            messageText.textContent = text;
            message.style.opacity = 1;
            
            setTimeout(() => {
                message.style.opacity = 0;
            }, duration);
        }

        function updateLoadingProgress(percent, text) {
            loadingProgress = percent;
            document.getElementById('loading-bar').style.width = `${percent}%`;
            document.getElementById('loading-text').textContent = text;
        }

        // =============================================
        // ========== UTILITY FUNCTIONS ==========
        // =============================================

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =============================================
        // ========== START THE GAME ==========
        // =============================================

        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
